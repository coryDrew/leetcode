package com.zcy.DP.digitDP;

public class Introduction {
    //数位 dp 其实就是让你处理出某一区间范围内满足条件的数的个数，但是一般这个区间范围都是令人绝望的大...
    // 比如 1e9 都算良心了，常规的都是 1e18 甚至是 1e10n （n 一般为 3 或 5）次这样的...
    //
    //数位dp 的一般解法
    //那么我们知道肯定不能在区间内一个个去判断数字是否满足条件，于是我们就引入了 数位处理 的概念：
    //
    //处理不多于 i 位的数中 （如 i = 10、100、1000、1e4、1e5）有多少数满足条件，dp[i] 就表示小于等于 10i 的数中，有多少数满足条件。
    //
    //但大部分题目与数字本身有一定关系（如不能出现某些特定数字或者必须出现某些式子之类的），那么我们就要多加一维（或者多维）来进行转移，
    //
    //那么 dp[i][j] 就表示第 i 位为 j 的，满足条件的数字有多少个。
    //
    //接下来我们再按位对于 区间端点 进行处理。这里为什么是对区间端点处理？（不是显然么？不然你枚举区间内每个数？）
    //
    //回想之前的操作，我们可以用预处理出的信息来计算出 1 ~ 某个数  的范围内有多少数满足条件，又因为我们计算出的是前缀信息，满足区间可加（减）性，
    //
    //于是我们可以计算出 1到L−1 和 1到R （ [L,R] 为要计算的满足条件的数字所处的区间范围 ）这两个区间内有多少数满足条件，然后减一减答案就出来了。
    //
    //具体怎么实现？我们一般考虑在当前处理的位 （i） 上固定一个数字（但这个数要小于 n 的第 i 位），然后易知，后面的数字我们随便填都行，
    //
    //弄完后我们把 n 的第 i 位当做填上去了（或者是记录下来和下一位作比较，这要看题目而定），迭代处理接下来的步骤。
    //
    //然而数位dp 说是说 dp ，有的时候 dp 数组是预处理出来累加答案的...优秀！
    //
    //
    //
    //相信这些东西看完也没多大用处（毕竟实践出真知嘛，大家都是做题做着做着才明白理论都在讲啥的么...
}
